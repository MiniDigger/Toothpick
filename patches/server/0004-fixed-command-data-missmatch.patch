From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ysl3000 <yannicklamprecht@live.de>
Date: Sat, 22 Aug 2020 16:23:52 +0200
Subject: [PATCH] fixed command data missmatch


diff --git a/src/main/java/net/minecraft/core/BlockPos.java b/src/main/java/net/minecraft/core/BlockPos.java
index 24e97d4e2c5777578bb7ccc57071b83ac66aa420..c17a4816e5739155d2407af1777452403f512a59 100644
--- a/src/main/java/net/minecraft/core/BlockPos.java
+++ b/src/main/java/net/minecraft/core/BlockPos.java
@@ -118,6 +118,9 @@ public class BlockPos extends Vec3i {
         return this.offset(-baseblockposition.getX(), -baseblockposition.getY(), -baseblockposition.getZ());
     }
 
+    public BlockPos up() {
+        return this.above();
+    } // Toothpick
     @Override
     public BlockPos above() {
         return new BlockPos(this.getX(), this.getY() + 1, this.getZ()); // Paper - Optimize BlockPosition
diff --git a/src/main/java/net/minecraft/core/Vec3i.java b/src/main/java/net/minecraft/core/Vec3i.java
index 862f1043cb006ca4171d2a0f1ba058f8fd48626d..7437c3c0793d83dfea92bb5d659b1c614935dd26 100644
--- a/src/main/java/net/minecraft/core/Vec3i.java
+++ b/src/main/java/net/minecraft/core/Vec3i.java
@@ -85,6 +85,9 @@ public class Vec3i implements Comparable<Vec3i> {
         this.z = i;
     }
 
+    public Vec3i up() {
+        return this.above();
+    } // Toothpick
     public Vec3i above() {
         return this.above(1);
     }
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index b173bdccff755664450b280d582cb11c056f8a47..ca84433827d57a1d457fb19ee45f47ae13b7b4ae 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -206,7 +206,7 @@ public class Main {
 
             convertable_conversionsession.a((IRegistryCustom) iregistrycustom_dimension, (SaveData) object);
             */
-            Class.forName("net.minecraft.server.VillagerTrades");// Paper - load this sync so it won't fail later async
+            Class.forName("net.minecraft.world.entity.npc.VillagerTrades");// Paper - load this sync so it won't fail later async
             final DedicatedServer dedicatedserver = (DedicatedServer) MinecraftServer.spin((thread) -> {
                 DedicatedServer dedicatedserver1 = new DedicatedServer(optionset, datapackconfiguration1, thread, iregistrycustom_dimension, convertable_conversionsession, resourcepackrepository, datapackresources, null, dedicatedserversettings, DataFixers.getDataFixerOH(), minecraftsessionservice, gameprofilerepository, usercache, LoggerChunkProgressListener::new);
 
diff --git a/src/main/java/net/minecraft/server/commands/data/BlockDataAccessor.java b/src/main/java/net/minecraft/server/commands/data/BlockDataAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb27042cd5a1decdd9dc184c372646e5c1175125
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/data/BlockDataAccessor.java
@@ -0,0 +1,72 @@
+package net.minecraft.server.commands.data;
+
+import com.mojang.brigadier.builder.ArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Locale;
+import java.util.function.Function;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.NbtPathArgument.NbtPath;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.server.commands.data.DataCommands.c;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+
+public class BlockDataAccessor implements DataAccessor {
+    private static final SimpleCommandExceptionType ERROR_NOT_A_BLOCK_ENTITY = new SimpleCommandExceptionType(new TranslatableComponent("commands.data.block.invalid"));
+    public static final Function<String, c> PROVIDER = (var0) -> new c() {
+        public DataAccessor access(CommandContext<CommandSourceStack> var0x) throws CommandSyntaxException {
+            BlockPos var1 = BlockPosArgument.getLoadedBlockPos(var0x, var0 + "Pos");
+            BlockEntity var2 = ((CommandSourceStack)var0x.getSource()).getLevel().getBlockEntity(var1);
+            if (var2 == null) {
+                throw BlockDataAccessor.ERROR_NOT_A_BLOCK_ENTITY.create();
+            } else {
+                return new BlockDataAccessor(var2, var1);
+            }
+        }
+
+        public ArgumentBuilder<CommandSourceStack, ?> a(ArgumentBuilder<CommandSourceStack, ?> var0x, Function<ArgumentBuilder<CommandSourceStack, ?>, ArgumentBuilder<CommandSourceStack, ?>> var1) {
+            return var0x.then(Commands.literal("block").then((ArgumentBuilder)var1.apply(Commands.argument(var0 + "Pos", BlockPosArgument.blockPos()))));
+        }
+    };
+    private final BlockEntity entity;
+    private final BlockPos pos;
+
+    public BlockDataAccessor(BlockEntity var0, BlockPos var1) {
+        this.entity = var0;
+        this.pos = var1;
+    }
+
+    public void setData(CompoundTag var0) {
+        var0.putInt("x", this.pos.getX());
+        var0.putInt("y", this.pos.getY());
+        var0.putInt("z", this.pos.getZ());
+        BlockState var1 = this.entity.getLevel().getType(this.pos);
+        this.entity.load(var1, var0);
+        this.entity.setChanged();
+        this.entity.getLevel().notify(this.pos, var1, var1, 3);
+    }
+
+    public CompoundTag getData() {
+        return this.entity.save(new CompoundTag());
+    }
+
+    public Component getModifiedSuccess() {
+        return new TranslatableComponent("commands.data.block.modified", new Object[]{this.pos.getX(), this.pos.getY(), this.pos.getZ()});
+    }
+
+    public Component getPrintSuccess(Tag var0) {
+        return new TranslatableComponent("commands.data.block.query", new Object[]{this.pos.getX(), this.pos.getY(), this.pos.getZ(), var0.getPrettyDisplay()});
+    }
+
+    public Component getPrintSuccess(NbtPath var0, double var1, int var3) {
+        return new TranslatableComponent("commands.data.block.get", new Object[]{var0, this.pos.getX(), this.pos.getY(), this.pos.getZ(), String.format(Locale.ROOT, "%.2f", var1), var3});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/data/DataAccessor.java b/src/main/java/net/minecraft/server/commands/data/DataAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d17e227202303b97c2cf3f57045ffd245e884d0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/data/DataAccessor.java
@@ -0,0 +1,24 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
+package net.minecraft.server.commands.data;
+
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.minecraft.commands.arguments.NbtPathArgument.NbtPath;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+
+public interface DataAccessor {
+    void setData(CompoundTag var1) throws CommandSyntaxException;
+
+    CompoundTag getData() throws CommandSyntaxException;
+
+    Component getModifiedSuccess();
+
+    Component getPrintSuccess(Tag var1);
+
+    Component getPrintSuccess(NbtPath var1, double var2, int var4);
+}
diff --git a/src/main/java/net/minecraft/server/commands/data/DataCommands.java b/src/main/java/net/minecraft/server/commands/data/DataCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b4be02dc02937c0ec61be5f060eb893c0427b61
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/data/DataCommands.java
@@ -0,0 +1,315 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
+package net.minecraft.server.commands.data;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.DoubleArgumentType;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.builder.ArgumentBuilder;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.CompoundTagArgument;
+import net.minecraft.commands.arguments.NbtPathArgument;
+import net.minecraft.commands.arguments.NbtTagArgument;
+import net.minecraft.commands.arguments.NbtPathArgument.NbtPath;
+import net.minecraft.nbt.CollectionTag;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.NumericTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.util.Mth;
+
+public class DataCommands {
+    private static final SimpleCommandExceptionType ERROR_MERGE_UNCHANGED = new SimpleCommandExceptionType(new TranslatableComponent("commands.data.merge.failed"));
+    private static final DynamicCommandExceptionType ERROR_GET_NOT_NUMBER = new DynamicCommandExceptionType((var0) -> {
+        return new TranslatableComponent("commands.data.get.invalid", var0);
+    });
+    private static final DynamicCommandExceptionType ERROR_GET_NON_EXISTENT = new DynamicCommandExceptionType((var0) -> {
+        return new TranslatableComponent("commands.data.get.unknown", var0);
+    });
+    private static final SimpleCommandExceptionType ERROR_MULTIPLE_TAGS = new SimpleCommandExceptionType(new TranslatableComponent("commands.data.get.multiple"));
+    private static final DynamicCommandExceptionType ERROR_EXPECTED_LIST = new DynamicCommandExceptionType((var0) -> {
+        return new TranslatableComponent("commands.data.modify.expected_list", var0);
+    });
+    private static final DynamicCommandExceptionType ERROR_EXPECTED_OBJECT = new DynamicCommandExceptionType((var0) -> {
+        return new TranslatableComponent("commands.data.modify.expected_object", var0);
+    });
+    private static final DynamicCommandExceptionType ERROR_INVALID_INDEX = new DynamicCommandExceptionType((var0) -> {
+        return new TranslatableComponent("commands.data.modify.invalid_index", var0);
+    });
+    public static final List<Function<String, DataCommands.c>> ALL_PROVIDERS;
+    public static final List<DataCommands.c> TARGET_PROVIDERS;
+    public static final List<DataCommands.c> SOURCE_PROVIDERS;
+
+    public static void register(CommandDispatcher<CommandSourceStack> var0) {
+        LiteralArgumentBuilder<CommandSourceStack> var1 = Commands.literal("data").requires((var0x) -> {
+            return var0x.hasPermission(2);
+        });
+        Iterator var2 = TARGET_PROVIDERS.iterator();
+
+        while(var2.hasNext()) {
+            DataCommands.c var3 = (DataCommands.c)var2.next();
+            ((LiteralArgumentBuilder)var1.then(var3.a(Commands.literal("merge"), (var1x) -> {
+                return var1x.then(Commands.argument("nbt", CompoundTagArgument.compoundTag()).executes((var1Merge) -> {
+                    return mergeData(var1Merge.getSource(), var3.access(var1Merge), CompoundTagArgument.getCompoundTag(var1Merge, "nbt"));
+                }));
+            }))).then(var3.a(Commands.literal("get"), (var1x) -> {
+                return var1x.executes((var1Get) -> {
+                    return getData((CommandSourceStack)var1Get.getSource(), var3.access(var1Get));
+                }).then(((RequiredArgumentBuilder)Commands.argument("path", NbtPathArgument.nbtPath()).executes((var1Path) -> {
+                    return getData(var1Path.getSource(), var3.access(var1Path), NbtPathArgument.getPath(var1Path, "path"));
+                })).then(Commands.argument("scale", DoubleArgumentType.doubleArg()).executes((var1Scale) -> {
+                    return getNumeric(var1Scale.getSource(), var3.access(var1Scale), NbtPathArgument.getPath(var1Scale, "path"), DoubleArgumentType.getDouble(var1Scale, "scale"));
+                })));
+            })).then(var3.a(Commands.literal("remove"), (var1x) -> {
+                return var1x.then(Commands.argument("path", NbtPathArgument.nbtPath()).executes((var1Path) -> {
+                    return removeData(var1Path.getSource(), var3.access(var1Path), NbtPathArgument.getPath(var1Path, "path"));
+                }));
+            })).then(decorateModification((var0x, var1x) -> {
+                var0x.then(Commands.literal("insert").then(Commands.argument("index", IntegerArgumentType.integer()).then(var1x.create((var0Index, var1Index, var2Index, var3Index) -> {
+                    int var4 = IntegerArgumentType.getInteger(var0Index, "index");
+                    return insertAtIndex(var4, var1Index, var2Index, var3Index);
+                })))).then(Commands.literal("prepend").then(var1x.create((var0Prepend, var1Prepend, var2Prepend, var3Prepend) -> {
+                    return insertAtIndex(0, var1Prepend, var2Prepend, var3Prepend);
+                }))).then(Commands.literal("append").then(var1x.create((var0Append, var1Append, var2Append, var3Append) -> {
+                    return insertAtIndex(-1, var1Append, var2Append, var3Append);
+                }))).then(Commands.literal("set").then(var1x.create((var0Set, var1Set, var2Set, var3Set) -> {
+                    Tag var10002 = Iterables.getLast(var3Set);
+                    var10002.getClass();
+                    return var2Set.set(var1Set, var10002::copy);
+                }))).then(Commands.literal("merge").then(var1x.create((var0Merge, var1Merge, var2Merge, var3Merge) -> {
+                    Collection<Tag> var4 = var2Merge.getOrCreate(var1Merge, CompoundTag::new);
+                    int var5 = 0;
+
+                    CompoundTag var8;
+                    CompoundTag var9;
+                    for(Iterator var6 = var4.iterator(); var6.hasNext(); var5 += var9.equals(var8) ? 0 : 1) {
+                        Tag var7 = (Tag)var6.next();
+                        if (!(var7 instanceof CompoundTag)) {
+                            throw ERROR_EXPECTED_OBJECT.create(var7);
+                        }
+
+                        var8 = (CompoundTag)var7;
+                        var9 = var8.copy();
+                        Iterator var10 = var3Merge.iterator();
+
+                        while(var10.hasNext()) {
+                            Tag var11 = (Tag)var10.next();
+                            if (!(var11 instanceof CompoundTag)) {
+                                throw ERROR_EXPECTED_OBJECT.create(var11);
+                            }
+
+                            var8.merge((CompoundTag)var11);
+                        }
+                    }
+
+                    return var5;
+                })));
+            }));
+        }
+
+        var0.register(var1);
+    }
+
+    private static int insertAtIndex(int var0, CompoundTag var1, NbtPath var2, List<Tag> var3) throws CommandSyntaxException {
+        Collection<Tag> var4 = var2.getOrCreate(var1, ListTag::new);
+        int var5 = 0;
+
+        boolean var8;
+        for(Iterator var6 = var4.iterator(); var6.hasNext(); var5 += var8 ? 1 : 0) {
+            Tag var7 = (Tag)var6.next();
+            if (!(var7 instanceof CollectionTag)) {
+                throw ERROR_EXPECTED_LIST.create(var7);
+            }
+
+            var8 = false;
+            CollectionTag<?> var9 = (CollectionTag)var7;
+            int var10 = var0 < 0 ? var9.size() + var0 + 1 : var0;
+            Iterator var11 = var3.iterator();
+
+            while(var11.hasNext()) {
+                Tag var12 = (Tag)var11.next();
+
+                try {
+                    if (var9.addTag(var10, var12.copy())) {
+                        ++var10;
+                        var8 = true;
+                    }
+                } catch (IndexOutOfBoundsException var14) {
+                    throw ERROR_INVALID_INDEX.create(var10);
+                }
+            }
+        }
+
+        return var5;
+    }
+
+    private static ArgumentBuilder<CommandSourceStack, ?> decorateModification(BiConsumer<ArgumentBuilder<CommandSourceStack, ?>, DataCommands.DataManipulatorDecorator> var0) {
+        LiteralArgumentBuilder<CommandSourceStack> var1 = Commands.literal("modify");
+        Iterator var2 = TARGET_PROVIDERS.iterator();
+
+        while(var2.hasNext()) {
+            DataCommands.c var3 = (DataCommands.c)var2.next();
+            var3.a(var1, (var2x) -> {
+                ArgumentBuilder<CommandSourceStack, ?> var3x = Commands.argument("targetPath", NbtPathArgument.nbtPath());
+                Iterator var4 = SOURCE_PROVIDERS.iterator();
+
+                while(var4.hasNext()) {
+                    DataCommands.c var5 = (DataCommands.c)var4.next();
+                    var0.accept(var3x, (var2From) -> {
+                        return var5.a(Commands.literal("from"), (var3xFrom) -> {
+                            return var3xFrom.executes((var3xx) -> {
+                                List<Tag> var4List = Collections.singletonList(var5.access(var3xx).getData());
+                                return manipulateData(var3xx, var3, var2From, var4List);
+                            }).then(Commands.argument("sourcePath", NbtPathArgument.nbtPath()).executes((var3xx) -> {
+                                DataAccessor var4Accessor = var5.access(var3xx);
+                                NbtPath var5x = NbtPathArgument.getPath(var3xx, "sourcePath");
+                                List<Tag> var6 = var5x.get(var4Accessor.getData());
+                                return manipulateData(var3xx, var3, var2From, var6);
+                            }));
+                        });
+                    });
+                }
+
+                var0.accept(var3x, (var1Value) -> {
+                    return Commands.literal("value").then(Commands.argument("value", NbtTagArgument.nbtTag()).executes((var2Value) -> {
+                        List<Tag> var3xTagList = Collections.singletonList(NbtTagArgument.getNbtTag(var2Value, "value"));
+                        return manipulateData(var2Value, var3, var1Value, var3xTagList);
+                    }));
+                });
+                return var2x.then(var3x);
+            });
+        }
+
+        return var1;
+    }
+
+    private static int manipulateData(CommandContext<CommandSourceStack> var0, DataCommands.c var1, DataCommands.DataManipulator var2, List<Tag> var3) throws CommandSyntaxException {
+        DataAccessor var4 = var1.access(var0);
+        NbtPath var5 = NbtPathArgument.getPath(var0, "targetPath");
+        CompoundTag var6 = var4.getData();
+        int var7 = var2.modify(var0, var6, var5, var3);
+        if (var7 == 0) {
+            throw ERROR_MERGE_UNCHANGED.create();
+        } else {
+            var4.setData(var6);
+            var0.getSource().sendSuccess(var4.getModifiedSuccess(), true);
+            return var7;
+        }
+    }
+
+    private static int removeData(CommandSourceStack var0, DataAccessor var1, NbtPath var2) throws CommandSyntaxException {
+        CompoundTag var3 = var1.getData();
+        int var4 = var2.remove(var3);
+        if (var4 == 0) {
+            throw ERROR_MERGE_UNCHANGED.create();
+        } else {
+            var1.setData(var3);
+            var0.sendSuccess(var1.getModifiedSuccess(), true);
+            return var4;
+        }
+    }
+
+    private static Tag getSingleTag(NbtPath var0, DataAccessor var1) throws CommandSyntaxException {
+        Collection<Tag> var2 = var0.get(var1.getData());
+        Iterator<Tag> var3 = var2.iterator();
+        Tag var4 = var3.next();
+        if (var3.hasNext()) {
+            throw ERROR_MULTIPLE_TAGS.create();
+        } else {
+            return var4;
+        }
+    }
+
+    private static int getData(CommandSourceStack var0, DataAccessor var1, NbtPath var2) throws CommandSyntaxException {
+        Tag var3 = getSingleTag(var2, var1);
+        int var4;
+        if (var3 instanceof NumericTag) {
+            var4 = Mth.floor(((NumericTag)var3).getAsDouble());
+        } else if (var3 instanceof CollectionTag) {
+            var4 = ((CollectionTag)var3).size();
+        } else if (var3 instanceof CompoundTag) {
+            var4 = ((CompoundTag)var3).size();
+        } else {
+            if (!(var3 instanceof StringTag)) {
+                throw ERROR_GET_NON_EXISTENT.create(var2.toString());
+            }
+
+            var4 = var3.getAsString().length();
+        }
+
+        var0.sendSuccess(var1.getPrintSuccess(var3), false);
+        return var4;
+    }
+
+    private static int getNumeric(CommandSourceStack var0, DataAccessor var1, NbtPath var2, double var3) throws CommandSyntaxException {
+        Tag var5 = getSingleTag(var2, var1);
+        if (!(var5 instanceof NumericTag)) {
+            throw ERROR_GET_NOT_NUMBER.create(var2.toString());
+        } else {
+            int var6 = Mth.floor(((NumericTag)var5).getAsDouble() * var3);
+            var0.sendSuccess(var1.getPrintSuccess(var2, var3, var6), false);
+            return var6;
+        }
+    }
+
+    private static int getData(CommandSourceStack var0, DataAccessor var1) throws CommandSyntaxException {
+        var0.sendSuccess(var1.getPrintSuccess(var1.getData()), false);
+        return 1;
+    }
+
+    private static int mergeData(CommandSourceStack var0, DataAccessor var1, CompoundTag var2) throws CommandSyntaxException {
+        CompoundTag var3 = var1.getData();
+        CompoundTag var4 = var3.copy().merge(var2);
+        if (var3.equals(var4)) {
+            throw ERROR_MERGE_UNCHANGED.create();
+        } else {
+            var1.setData(var4);
+            var0.sendSuccess(var1.getModifiedSuccess(), true);
+            return 1;
+        }
+    }
+
+    static {
+        ALL_PROVIDERS = ImmutableList.of(EntityDataAccessor.PROVIDER, BlockDataAccessor.PROVIDER, StorageDataAccessor.PROVIDER);
+        TARGET_PROVIDERS = ALL_PROVIDERS.stream().map((var0) -> {
+            return var0.apply("target");
+        }).collect(ImmutableList.toImmutableList());
+        SOURCE_PROVIDERS = ALL_PROVIDERS.stream().map((var0) -> {
+            return var0.apply("source");
+        }).collect(ImmutableList.toImmutableList());
+    }
+
+    public interface c {
+        DataAccessor access(CommandContext<CommandSourceStack> var1) throws CommandSyntaxException;
+
+        ArgumentBuilder<CommandSourceStack, ?> a(ArgumentBuilder<CommandSourceStack, ?> var1, Function<ArgumentBuilder<CommandSourceStack, ?>, ArgumentBuilder<CommandSourceStack, ?>> var2);
+    }
+
+    interface DataManipulatorDecorator {
+        ArgumentBuilder<CommandSourceStack, ?> create(DataCommands.DataManipulator var1);
+    }
+
+    interface DataManipulator {
+        int modify(CommandContext<CommandSourceStack> var1, CompoundTag var2, NbtPath var3, List<Tag> var4) throws CommandSyntaxException;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/data/EntityDataAccessor.java b/src/main/java/net/minecraft/server/commands/data/EntityDataAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..3cb9a2c40b63757292e2d8cd7f8c88aa40a1f494
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/data/EntityDataAccessor.java
@@ -0,0 +1,72 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
+package net.minecraft.server.commands.data;
+
+import com.mojang.brigadier.builder.ArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Locale;
+import java.util.UUID;
+import java.util.function.Function;
+import net.minecraft.advancements.critereon.NbtPredicate;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.NbtPathArgument.NbtPath;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.server.commands.data.DataCommands.c;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+
+public class EntityDataAccessor implements DataAccessor {
+    private static final SimpleCommandExceptionType ERROR_NO_PLAYERS = new SimpleCommandExceptionType(new TranslatableComponent("commands.data.entity.invalid"));
+    public static final Function<String, c> PROVIDER = (var0) -> {
+        return new c() {
+            public DataAccessor access(CommandContext<CommandSourceStack> var0x) throws CommandSyntaxException {
+                return new EntityDataAccessor(EntityArgument.getEntity(var0x, var0));
+            }
+
+            public ArgumentBuilder<CommandSourceStack, ?> a(ArgumentBuilder<CommandSourceStack, ?> var0x, Function<ArgumentBuilder<CommandSourceStack, ?>, ArgumentBuilder<CommandSourceStack, ?>> var1) {
+                return var0x.then(Commands.literal("entity").then((ArgumentBuilder)var1.apply(Commands.argument(var0, EntityArgument.entity()))));
+            }
+        };
+    };
+    private final Entity entity;
+
+    public EntityDataAccessor(Entity var0) {
+        this.entity = var0;
+    }
+
+    public void setData(CompoundTag var0) throws CommandSyntaxException {
+        if (this.entity instanceof Player) {
+            throw ERROR_NO_PLAYERS.create();
+        } else {
+            UUID var1 = this.entity.getUUID();
+            this.entity.load(var0);
+            this.entity.setUUID(var1);
+        }
+    }
+
+    public CompoundTag getData() {
+        return NbtPredicate.getEntityTagToCompare(this.entity);
+    }
+
+    public Component getModifiedSuccess() {
+        return new TranslatableComponent("commands.data.entity.modified", new Object[]{this.entity.getDisplayName()});
+    }
+
+    public Component getPrintSuccess(Tag var0) {
+        return new TranslatableComponent("commands.data.entity.query", new Object[]{this.entity.getDisplayName(), var0.getPrettyDisplay()});
+    }
+
+    public Component getPrintSuccess(NbtPath var0, double var1, int var3) {
+        return new TranslatableComponent("commands.data.entity.get", new Object[]{var0, this.entity.getDisplayName(), String.format(Locale.ROOT, "%.2f", var1), var3});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/data/StorageDataAccessor.java b/src/main/java/net/minecraft/server/commands/data/StorageDataAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..9dbe3f9ffae7a75fcdc992f6a20dbd9b9c02010d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/data/StorageDataAccessor.java
@@ -0,0 +1,72 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
+package net.minecraft.server.commands.data;
+
+import com.mojang.brigadier.builder.ArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import java.util.Locale;
+import java.util.function.Function;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.SharedSuggestionProvider;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
+import net.minecraft.commands.arguments.NbtPathArgument.NbtPath;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.commands.data.DataCommands.c;
+import net.minecraft.world.level.storage.CommandStorage;
+
+public class StorageDataAccessor implements DataAccessor {
+    private static final SuggestionProvider<CommandSourceStack> SUGGEST_STORAGE = (var0, var1) -> {
+        return SharedSuggestionProvider.suggestResource(getGlobalTags(var0).keys(), var1);
+    };
+    public static final Function<String, c> PROVIDER = (var0) -> {
+        return new c() {
+            public DataAccessor access(CommandContext<CommandSourceStack> var0x) {
+                return new StorageDataAccessor(StorageDataAccessor.getGlobalTags(var0x), ResourceLocationArgument.getId(var0x, var0));
+            }
+
+            public ArgumentBuilder<CommandSourceStack, ?> a(ArgumentBuilder<CommandSourceStack, ?> var0x, Function<ArgumentBuilder<CommandSourceStack, ?>, ArgumentBuilder<CommandSourceStack, ?>> var1) {
+                return var0x.then(Commands.literal("storage").then((ArgumentBuilder)var1.apply(Commands.argument(var0, ResourceLocationArgument.id()).suggests(StorageDataAccessor.SUGGEST_STORAGE))));
+            }
+        };
+    };
+    private final CommandStorage storage;
+    private final ResourceLocation id;
+
+    private static CommandStorage getGlobalTags(CommandContext<CommandSourceStack> var0) {
+        return ((CommandSourceStack)var0.getSource()).getServer().getCommandStorage();
+    }
+
+    private StorageDataAccessor(CommandStorage var0, ResourceLocation var1) {
+        this.storage = var0;
+        this.id = var1;
+    }
+
+    public void setData(CompoundTag var0) {
+        this.storage.set(this.id, var0);
+    }
+
+    public CompoundTag getData() {
+        return this.storage.get(this.id);
+    }
+
+    public Component getModifiedSuccess() {
+        return new TranslatableComponent("commands.data.storage.modified", new Object[]{this.id});
+    }
+
+    public Component getPrintSuccess(Tag var0) {
+        return new TranslatableComponent("commands.data.storage.query", new Object[]{this.id, var0.getPrettyDisplay()});
+    }
+
+    public Component getPrintSuccess(NbtPath var0, double var1, int var3) {
+        return new TranslatableComponent("commands.data.storage.get", new Object[]{var0, this.id, String.format(Locale.ROOT, "%.2f", var1), var3});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index dc94804f912a57391434fe56067fa98871135209..b618bf2e27e2d20b2a544536b8844d0dca31cbeb 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -220,7 +220,7 @@ public class ServerGamePacketListenerImpl implements ServerGamePacketListener {
     private long keepAliveChallenge; private void setKeepAliveID(long keepAliveID) { this.keepAliveChallenge = keepAliveID;}; private long getKeepAliveID() {return this.keepAliveChallenge; };  // Paper - OBFHELPER
     // CraftBukkit start - multithreaded fields
     private volatile int chatSpamTickCount;
-    private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(ServerGamePacketListenerImpl.class, "chatThrottle");
+    private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(ServerGamePacketListenerImpl.class, "chatSpamTickCount");
     private final java.util.concurrent.atomic.AtomicInteger tabSpamLimiter = new java.util.concurrent.atomic.AtomicInteger(); // Paper - configurable tab spam limits
     // CraftBukkit end
     private int dropSpamTickCount;
diff --git a/src/main/resources/configurations/bukkit.yml b/src/main/resources/configurations/bukkit.yml
new file mode 100644
index 0000000000000000000000000000000000000000..6474a7fb738e1238cc272afc5ff14b645947e688
--- /dev/null
+++ b/src/main/resources/configurations/bukkit.yml
@@ -0,0 +1,41 @@
+# This is the main configuration file for Bukkit.
+# As you can see, there's actually not that much to configure without any plugins.
+# For a reference for any variable inside this file, check out the Bukkit Wiki at
+# https://www.spigotmc.org/go/bukkit-yml
+# 
+# If you need help on this file, feel free to join us on irc or leave a message
+# on the forums asking for advice.
+# 
+# IRC: #spigot @ irc.spi.gt
+#    (If this means nothing to you, just go to https://www.spigotmc.org/go/irc )
+# Forums: https://www.spigotmc.org/
+# Bug tracker: https://www.spigotmc.org/go/bugs
+
+
+settings:
+    allow-end: true
+    warn-on-overload: true
+    permissions-file: permissions.yml
+    update-folder: update
+    plugin-profiling: false
+    connection-throttle: 4000
+    query-plugins: true
+    deprecated-verbose: default
+    shutdown-message: Server closed
+    minimum-api: none
+spawn-limits:
+    monsters: 70
+    animals: 10
+    water-animals: 15
+    water-ambient: 20
+    ambient: 15
+chunk-gc:
+    period-in-ticks: 600
+ticks-per:
+    animal-spawns: 400
+    monster-spawns: 1
+    water-spawns: 1
+    water-ambient-spawns: 1
+    ambient-spawns: 1
+    autosave: 6000
+aliases: now-in-commands.yml
diff --git a/src/main/resources/configurations/commands.yml b/src/main/resources/configurations/commands.yml
new file mode 100644
index 0000000000000000000000000000000000000000..0f45c397df38e8af1c8b5bb8ca24f54a88e5880b
--- /dev/null
+++ b/src/main/resources/configurations/commands.yml
@@ -0,0 +1,17 @@
+# This is the commands configuration file for Bukkit.
+# For documentation on how to make use of this file, check out the Bukkit Wiki at
+# https://www.spigotmc.org/go/commands-yml
+# 
+# If you need help on this file, feel free to join us on irc or leave a message
+# on the forums asking for advice.
+# 
+# IRC: #spigot @ irc.spi.gt
+#    (If this means nothing to you, just go to https://www.spigotmc.org/go/irc )
+# Forums: https://www.spigotmc.org/
+# Bug tracker: https://www.spigotmc.org/go/bugs
+
+command-block-overrides: []
+ignore-vanilla-permissions: false
+aliases:
+    icanhasbukkit:
+      - "version $1-"
diff --git a/src/main/resources/configurations/help.yml b/src/main/resources/configurations/help.yml
new file mode 100644
index 0000000000000000000000000000000000000000..15c3d07070624ad453032a02d8d4d3f26bd6cb8d
--- /dev/null
+++ b/src/main/resources/configurations/help.yml
@@ -0,0 +1,55 @@
+# This is the help configuration file for Bukkit.
+# 
+# By default you do not need to modify this file. Help topics for all plugin commands are automatically provided by
+# or extracted from your installed plugins. You only need to modify this file if you wish to add new help pages to
+# your server or override the help pages of existing plugin commands.
+# 
+# This file is divided up into the following parts:
+# -- general-topics: lists admin defined help topics
+# -- index-topics:   lists admin defined index topics
+# -- amend-topics:   lists topic amendments to apply to existing help topics
+# -- ignore-plugins: lists any plugins that should be excluded from help
+# 
+# Examples are given below. When amending command topic, the string <text> will be replaced with the existing value
+# in the help topic. Color codes can be used in topic text. The color code character is & followed by 0-F.
+# ================================================================
+# 
+# Set this to true to list the individual command help topics in the master help.
+# command-topics-in-master-index: true
+# 
+# Each general topic will show up as a separate topic in the help index along with all the plugin command topics.
+# general-topics:
+#     Rules:
+#         shortText: Rules of the server
+#         fullText: |
+#             &61. Be kind to your fellow players.
+#             &B2. No griefing.
+#             &D3. No swearing.
+#         permission: topics.rules
+# 
+# Each index topic will show up as a separate sub-index in the help index along with all the plugin command topics.
+# To override the default help index (displayed when the user executes /help), name the index topic "Default".
+# index-topics:
+#     Ban Commands:
+#         shortText: Player banning commands
+#         preamble: Moderator - do not abuse these commands
+#         permission: op
+#         commands:
+#             - /ban
+#             - /ban-ip
+#             - /banlist
+# 
+# Topic amendments are used to change the content of automatically generated plugin command topics.
+# amended-topics:
+#     /stop:
+#         shortText: Stops the server cold....in its tracks!
+#         fullText: <text> - This kills the server.
+#         permission: you.dont.have
+# 
+# Any plugin in the ignored plugins list will be excluded from help. The name must match the name displayed by
+# the /plugins command. Ignore "Bukkit" to remove the standard bukkit commands from the index. Ignore "All"
+# to completely disable automatic help topic generation.
+# ignore-plugins:
+#    - PluginNameOne
+#    - PluginNameTwo
+#    - PluginNameThree
diff --git a/src/main/resources/log4j2.component.properties b/src/main/resources/log4j2.component.properties
new file mode 100644
index 0000000000000000000000000000000000000000..30efeb5faf8e7faccf1b252fa0ed6a9fc31c40a7
--- /dev/null
+++ b/src/main/resources/log4j2.component.properties
@@ -0,0 +1,3 @@
+Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector
+log4j2.AsyncQueueFullPolicy="com.destroystokyo.paper.log.LogFullPolicy"
+log4j.skipJansi=true
diff --git a/src/main/resources/log4j2.xml b/src/main/resources/log4j2.xml
new file mode 100644
index 0000000000000000000000000000000000000000..8af159abd3d0cc94cf155fec5b384c42f69551bf
--- /dev/null
+++ b/src/main/resources/log4j2.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Configuration status="WARN" packages="com.mojang.util" shutdownHook="disable">
+    <Appenders>
+        <Queue name="ServerGuiConsole">
+            <PatternLayout pattern="[%d{HH:mm:ss} %level]: %msg%n" />
+        </Queue>
+        <TerminalConsole name="TerminalConsole">
+            <PatternLayout>
+                <LoggerNamePatternSelector defaultPattern="%highlightError{[%d{HH:mm:ss} %level]: [%logger] %minecraftFormatting{%msg}%n%xEx{full}}">
+                    <!-- Log root, Minecraft, Mojang and Bukkit loggers without prefix -->
+                    <!-- Disable prefix for various plugins that bypass the plugin logger -->
+                    <PatternMatch key=",net.minecraft.,Minecraft,com.mojang.,com.sk89q.,ru.tehkode.,Minecraft.AWE"
+                                  pattern="%highlightError{[%d{HH:mm:ss} %level]: %minecraftFormatting{%msg}%n%xEx{full}}" />
+                </LoggerNamePatternSelector>
+            </PatternLayout>
+        </TerminalConsole>
+        <RollingRandomAccessFile name="File" fileName="logs/latest.log" filePattern="logs/%d{yyyy-MM-dd}-%i.log.gz">
+            <PatternLayout>
+                <LoggerNamePatternSelector defaultPattern="[%d{HH:mm:ss}] [%t/%level]: [%logger] %minecraftFormatting{%msg}{strip}%n%xEx{full}">
+                    <!-- Log root, Minecraft, Mojang and Bukkit loggers without prefix -->
+                    <!-- Disable prefix for various plugins that bypass the plugin logger -->
+                    <PatternMatch key=",net.minecraft.,Minecraft,com.mojang.,com.sk89q.,ru.tehkode.,Minecraft.AWE"
+                                  pattern="[%d{HH:mm:ss}] [%t/%level]: %minecraftFormatting{%msg}{strip}%n%xEx{full}" />
+                </LoggerNamePatternSelector>
+            </PatternLayout>
+            <Policies>
+                <TimeBasedTriggeringPolicy />
+                <OnStartupTriggeringPolicy />
+            </Policies>
+            <DefaultRolloverStrategy max="1000"/>
+        </RollingRandomAccessFile>
+    </Appenders>
+    <Loggers>
+        <Root level="info">
+            <filters>
+                <MarkerFilter marker="NETWORK_PACKETS" onMatch="DENY" onMismatch="NEUTRAL" />
+            </filters>
+            <AppenderRef ref="File"/>
+            <AppenderRef ref="TerminalConsole" level="info"/>
+            <AppenderRef ref="ServerGuiConsole" level="info"/>
+        </Root>
+    </Loggers>
+</Configuration>
